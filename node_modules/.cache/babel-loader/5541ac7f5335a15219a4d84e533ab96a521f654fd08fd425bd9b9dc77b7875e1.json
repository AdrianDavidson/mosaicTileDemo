{"ast":null,"code":"'use strict';\n\nconst convertUnit = require('./convertUnit.js');\n\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n  return false;\n}\n\n/** @param {'-'|'+'} operator */\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex(x => x.node.type === node.type);\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n      // can cast because of the criterion used to find itemIndex\n      const otherValueNode = /** @type import('../parser').ValueExpression*/\n      collected[itemIndex].node;\n      const {\n        left: reducedNode,\n        right: current\n      } = convertNodesUnits(otherValueNode, node, precision);\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      }\n      // make sure reducedNode.value >= 0\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '+'\n        };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '-'\n        };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({\n          node,\n          preOperator\n        });\n      } else {\n        node.value *= -1;\n        collected.push({\n          node,\n          preOperator: flip(preOperator)\n        });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(collectRightOperator, node.right, collected, precision);\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision);\n      // prevent infinite recursive call\n      if (reducedNode.type !== 'MathExpression' || isAddSubOperator(reducedNode.operator)) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({\n          node: reducedNode,\n          preOperator\n        });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({\n      node,\n      preOperator\n    });\n  }\n}\n\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n  const withoutZeroItem = collected.filter(item => !(isValueType(item.node) && item.node.value === 0));\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node)) {\n    const firstZeroItem = collected.find(item => isValueType(item.node) && item.node.value === 0);\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  }\n\n  // make sure the preOperator of the first item is +\n  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node)) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n  let root = withoutZeroItem[0].node;\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node\n    };\n  }\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n  return applyNumberDivision(node.left, node.right.value);\n}\n\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor)\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor\n    }\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  }\n  // number * (expr)\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n  return node;\n}\n\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier)\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier\n    }\n  };\n}\n\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(right.value, right.unit, left.unit, precision);\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit\n        };\n      }\n      return {\n        left,\n        right\n      };\n    default:\n      return {\n        left,\n        right\n      };\n  }\n}\n\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\nfunction includesNoCssProperties(node) {\n  return node.content.type !== 'Function' && (node.content.type !== 'MathExpression' || node.content.right.type !== 'Function' && node.content.left.type !== 'Function');\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n    return node;\n  }\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n  return node;\n}\nmodule.exports = reduce;","map":{"version":3,"names":["convertUnit","require","isValueType","node","type","flip","operator","isAddSubOperator","collectAddSubItems","preOperator","collected","precision","Error","itemIndex","findIndex","x","value","otherValueNode","left","reducedNode","right","current","convertNodesUnits","push","collectRightOperator","reduce","content","reduceAddSubExpression","withoutZeroItem","filter","item","firstNonZeroItem","firstZeroItem","find","unshift","root","i","length","reduceDivisionExpression","unit","applyNumberDivision","divisor","reduceMultiplicationExpression","applyNumberMultiplication","multiplier","converted","includesNoCssProperties","module","exports"],"sources":["C:/Users/Adrian/Desktop/kisi_project/mosaicTileDemo/node_modules/postcss-calc/src/lib/reducer.js"],"sourcesContent":["'use strict';\nconst convertUnit = require('./convertUnit.js');\n\n/**\n * @param {import('../parser').CalcNode} node\n * @return {node is import('../parser').ValueExpression}\n */\nfunction isValueType(node) {\n  switch (node.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n  return false;\n}\n\n/** @param {'-'|'+'} operator */\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\n/**\n * @param {string} operator\n * @returns {operator is '+'|'-'}\n */\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\n/**\n * @typedef {{preOperator: '+'|'-', node: import('../parser').CalcNode}} Collectible\n */\n\n/**\n * @param {'+'|'-'} preOperator\n * @param {import('../parser').CalcNode} node\n * @param {Collectible[]} collected\n * @param {number} precision\n */\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n  if (isValueType(node)) {\n    const itemIndex = collected.findIndex((x) => x.node.type === node.type);\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n      // can cast because of the criterion used to find itemIndex\n      const otherValueNode = /** @type import('../parser').ValueExpression*/ (\n        collected[itemIndex].node\n      );\n      const { left: reducedNode, right: current } = convertNodesUnits(\n        otherValueNode,\n        node,\n        precision\n      );\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n      if (preOperator === '+') {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      }\n      // make sure reducedNode.value >= 0\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = { node: reducedNode, preOperator: '+' };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = { node: reducedNode, preOperator: '-' };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({ node, preOperator });\n      } else {\n        node.value *= -1;\n        collected.push({ node, preOperator: flip(preOperator) });\n      }\n    }\n  } else if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      const collectRightOperator =\n        preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(\n        collectRightOperator,\n        node.right,\n        collected,\n        precision\n      );\n    } else {\n      // * or /\n      const reducedNode = reduce(node, precision);\n      // prevent infinite recursive call\n      if (\n        reducedNode.type !== 'MathExpression' ||\n        isAddSubOperator(reducedNode.operator)\n      ) {\n        collectAddSubItems(preOperator, reducedNode, collected, precision);\n      } else {\n        collected.push({ node: reducedNode, preOperator });\n      }\n    }\n  } else if (node.type === 'ParenthesizedExpression') {\n    collectAddSubItems(preOperator, node.content, collected, precision);\n  } else {\n    collected.push({ node, preOperator });\n  }\n}\n\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n */\nfunction reduceAddSubExpression(node, precision) {\n  /** @type Collectible[] */\n  const collected = [];\n  collectAddSubItems('+', node, collected, precision);\n\n  const withoutZeroItem = collected.filter(\n    (item) => !(isValueType(item.node) && item.node.value === 0)\n  );\n  const firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n  if (\n    !firstNonZeroItem ||\n    (firstNonZeroItem.preOperator === '-' &&\n      !isValueType(firstNonZeroItem.node))\n  ) {\n    const firstZeroItem = collected.find(\n      (item) => isValueType(item.node) && item.node.value === 0\n    );\n    if (firstZeroItem) {\n      withoutZeroItem.unshift(firstZeroItem);\n    }\n  }\n\n  // make sure the preOperator of the first item is +\n  if (\n    withoutZeroItem[0].preOperator === '-' &&\n    isValueType(withoutZeroItem[0].node)\n  ) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  let root = withoutZeroItem[0].node;\n  for (let i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node,\n    };\n  }\n\n  return root;\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n}\n\n/**\n * apply (expr) / number\n *\n * @param {import('../parser').CalcNode} node\n * @param {number} divisor\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n  if (isValueType(node)) {\n    node.value /= divisor;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '/',\n    left: node,\n    right: {\n      type: 'Number',\n      value: divisor,\n    },\n  };\n}\n/**\n * @param {import('../parser').MathExpression} node\n */\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  }\n  // number * (expr)\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n  return node;\n}\n\n/**\n * apply (expr) * number\n * @param {number} multiplier\n * @param {import('../parser').CalcNode} node\n * @return {import('../parser').CalcNode}\n */\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node)) {\n    node.value *= multiplier;\n    return node;\n  }\n  if (node.type === 'MathExpression' && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: 'MathExpression',\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier),\n    };\n  }\n  // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n  return {\n    type: 'MathExpression',\n    operator: '*',\n    left: node,\n    right: {\n      type: 'Number',\n      value: multiplier,\n    },\n  };\n}\n\n/**\n * @param {import('../parser').ValueExpression} left\n * @param {import('../parser').ValueExpression} right\n * @param {number} precision\n */\nfunction convertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        const converted = convertUnit(\n          right.value,\n          right.unit,\n          left.unit,\n          precision\n        );\n\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit,\n        };\n      }\n\n      return { left, right };\n    default:\n      return { left, right };\n  }\n}\n\n/**\n * @param {import('../parser').ParenthesizedExpression} node\n */\nfunction includesNoCssProperties(node) {\n  return (\n    node.content.type !== 'Function' &&\n    (node.content.type !== 'MathExpression' ||\n      (node.content.right.type !== 'Function' &&\n        node.content.left.type !== 'Function'))\n  );\n}\n/**\n * @param {import('../parser').CalcNode} node\n * @param {number} precision\n * @return {import('../parser').CalcNode}\n */\nfunction reduce(node, precision) {\n  if (node.type === 'MathExpression') {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n    switch (node.operator) {\n      case '/':\n        return reduceDivisionExpression(node);\n      case '*':\n        return reduceMultiplicationExpression(node);\n    }\n\n    return node;\n  }\n\n  if (node.type === 'ParenthesizedExpression') {\n    if (includesNoCssProperties(node)) {\n      return reduce(node.content, precision);\n    }\n  }\n\n  return node;\n}\n\nmodule.exports = reduce;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}