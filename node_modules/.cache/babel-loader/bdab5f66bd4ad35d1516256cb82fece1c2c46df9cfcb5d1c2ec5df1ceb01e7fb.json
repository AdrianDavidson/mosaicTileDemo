{"ast":null,"code":"'use strict';\n\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1\n};\n\n/**\n * @param {number} value\n * @param {number | false} prec\n */\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n  return value;\n}\n\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression':\n      {\n        const {\n          left,\n          right,\n          operator: op\n        } = node;\n        let str = '';\n        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n          str += `(${stringify(left, prec)})`;\n        } else {\n          str += stringify(left, prec);\n        }\n        str += order[op] ? ` ${node.operator} ` : node.operator;\n        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {\n          str += `(${stringify(right, prec)})`;\n        } else {\n          str += stringify(right, prec);\n        }\n        return str;\n      }\n    case 'Number':\n      return round(node.value, prec).toString();\n    case 'Function':\n      return node.value.toString();\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n  const shouldPrintCalc = node.type === 'MathExpression' || node.type === 'Function';\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`;\n\n    // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item\n      });\n    }\n  }\n  return str;\n};","map":{"version":3,"names":["order","round","value","prec","precision","Math","pow","stringify","node","type","left","right","operator","op","str","toString","content","unit","module","exports","calc","originalValue","options","result","item","shouldPrintCalc","warnWhenCannotResolve","warn","plugin"],"sources":["C:/Users/Adrian/Desktop/kisi_project/mosaicTileDemo/node_modules/postcss-calc/src/lib/stringifier.js"],"sourcesContent":["'use strict';\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1,\n};\n\n/**\n * @param {number} value\n * @param {number | false} prec\n */\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n  return value;\n}\n\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression': {\n      const { left, right, operator: op } = node;\n      let str = '';\n      if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n        str += `(${stringify(left, prec)})`;\n      } else {\n        str += stringify(left, prec);\n      }\n\n      str += order[op] ? ` ${node.operator} ` : node.operator;\n\n      if (\n        right.type === 'MathExpression' &&\n        order[op] < order[right.operator]\n      ) {\n        str += `(${stringify(right, prec)})`;\n      } else {\n        str += stringify(right, prec);\n      }\n\n      return str;\n    }\n    case 'Number':\n      return round(node.value, prec).toString();\n    case 'Function':\n      return node.value.toString();\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n\n  const shouldPrintCalc =\n    node.type === 'MathExpression' || node.type === 'Function';\n\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`;\n\n    // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item,\n      });\n    }\n  }\n  return str;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}