{"ast":null,"code":"'use strict';\n\nconst selectorParser = require('postcss-selector-parser');\nconst valueParser = require('postcss-value-parser');\nconst {\n  parser\n} = require('../parser.js');\nconst reducer = require('./reducer.js');\nconst stringifier = require('./stringifier.js');\nconst MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;\n\n/**\n * @param {string} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformValue(value, options, result, item) {\n  return valueParser(value).walk(node => {\n    // skip anything which isn't a calc() function\n    if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {\n      return;\n    }\n\n    // stringify calc expression and produce an AST\n    const contents = valueParser.stringify(node.nodes);\n    const ast = parser.parse(contents);\n\n    // reduce AST to its simplest form, that is, either to a single value\n    // or a simplified calc expression\n    const reducedAst = reducer(ast, options.precision);\n\n    // stringify AST and write it back\n    /** @type {valueParser.Node} */\n    node.type = 'word';\n    node.value = stringifier(node.value, reducedAst, value, options, result, item);\n    return false;\n  }).toString();\n}\n/**\n * @param {import(\"postcss-selector-parser\").Selectors} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformSelector(value, options, result, item) {\n  return selectorParser(selectors => {\n    selectors.walk(node => {\n      // attribute value\n      // e.g. the \"calc(3*3)\" part of \"div[data-size=\"calc(3*3)\"]\"\n      if (node.type === 'attribute' && node.value) {\n        node.setValue(transformValue(node.value, options, result, item));\n      }\n\n      // tag value\n      // e.g. the \"calc(3*3)\" part of \"div:nth-child(2n + calc(3*3))\"\n      if (node.type === 'tag') {\n        node.value = transformValue(node.value, options, result, item);\n      }\n      return;\n    });\n  }).processSync(value);\n}\n\n/**\n * @param {any} node\n * @param {{precision: number, preserve: boolean, warnWhenCannotResolve: boolean}} options\n * @param {'value'|'params'|'selector'} property\n * @param {import(\"postcss\").Result} result\n */\nmodule.exports = (node, property, options, result) => {\n  let value = node[property];\n  try {\n    value = property === 'selector' ? transformSelector(node[property], options, result, node) : transformValue(node[property], options, result, node);\n  } catch (error) {\n    if (error instanceof Error) {\n      result.warn(error.message, {\n        node\n      });\n    } else {\n      result.warn('Error', {\n        node\n      });\n    }\n    return;\n  }\n\n  // if the preserve option is enabled and the value has changed, write the\n  // transformed value into a cloned node which is inserted before the current\n  // node, preserving the original value. Otherwise, overwrite the original\n  // value.\n  if (options.preserve && node[property] !== value) {\n    const clone = node.clone();\n    clone[property] = value;\n    node.parent.insertBefore(node, clone);\n  } else {\n    node[property] = value;\n  }\n};","map":{"version":3,"names":["selectorParser","require","valueParser","parser","reducer","stringifier","MATCH_CALC","transformValue","value","options","result","item","walk","node","type","test","contents","stringify","nodes","ast","parse","reducedAst","precision","toString","transformSelector","selectors","setValue","processSync","module","exports","property","error","Error","warn","message","preserve","clone","parent","insertBefore"],"sources":["C:/Users/Adrian/Desktop/kisi_project/mosaicTileDemo/node_modules/postcss-calc/src/lib/transform.js"],"sourcesContent":["'use strict';\nconst selectorParser = require('postcss-selector-parser');\nconst valueParser = require('postcss-value-parser');\n\nconst { parser } = require('../parser.js');\n\nconst reducer = require('./reducer.js');\nconst stringifier = require('./stringifier.js');\n\nconst MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;\n\n/**\n * @param {string} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformValue(value, options, result, item) {\n  return valueParser(value)\n    .walk((node) => {\n      // skip anything which isn't a calc() function\n      if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {\n        return;\n      }\n\n      // stringify calc expression and produce an AST\n      const contents = valueParser.stringify(node.nodes);\n      const ast = parser.parse(contents);\n\n      // reduce AST to its simplest form, that is, either to a single value\n      // or a simplified calc expression\n      const reducedAst = reducer(ast, options.precision);\n\n      // stringify AST and write it back\n      /** @type {valueParser.Node} */ (node).type = 'word';\n      node.value = stringifier(\n        node.value,\n        reducedAst,\n        value,\n        options,\n        result,\n        item\n      );\n\n      return false;\n    })\n    .toString();\n}\n/**\n * @param {import(\"postcss-selector-parser\").Selectors} value\n * @param {{precision: number, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n */\nfunction transformSelector(value, options, result, item) {\n  return selectorParser((selectors) => {\n    selectors.walk((node) => {\n      // attribute value\n      // e.g. the \"calc(3*3)\" part of \"div[data-size=\"calc(3*3)\"]\"\n      if (node.type === 'attribute' && node.value) {\n        node.setValue(transformValue(node.value, options, result, item));\n      }\n\n      // tag value\n      // e.g. the \"calc(3*3)\" part of \"div:nth-child(2n + calc(3*3))\"\n      if (node.type === 'tag') {\n        node.value = transformValue(node.value, options, result, item);\n      }\n\n      return;\n    });\n  }).processSync(value);\n}\n\n/**\n * @param {any} node\n * @param {{precision: number, preserve: boolean, warnWhenCannotResolve: boolean}} options\n * @param {'value'|'params'|'selector'} property\n * @param {import(\"postcss\").Result} result\n */\nmodule.exports = (node, property, options, result) => {\n  let value = node[property];\n\n  try {\n    value =\n      property === 'selector'\n        ? transformSelector(node[property], options, result, node)\n        : transformValue(node[property], options, result, node);\n  } catch (error) {\n    if (error instanceof Error) {\n      result.warn(error.message, { node });\n    } else {\n      result.warn('Error', { node });\n    }\n    return;\n  }\n\n  // if the preserve option is enabled and the value has changed, write the\n  // transformed value into a cloned node which is inserted before the current\n  // node, preserving the original value. Otherwise, overwrite the original\n  // value.\n  if (options.preserve && node[property] !== value) {\n    const clone = node.clone();\n    clone[property] = value;\n    node.parent.insertBefore(node, clone);\n  } else {\n    node[property] = value;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}